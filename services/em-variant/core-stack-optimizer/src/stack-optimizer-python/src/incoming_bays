from collections import OrderedDict
import copy
from matplotlib import cm, patches, pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np

existing_bays = {1: {'stack1': [('c11', 6), ('c9', 5)],
  'stack2': [('c3', 8), ('c10', 6), ('c12', 2), ('c2', 1)],
  'stack3': [('c5', 6), ('c7', 4)],
  'stack4': [('c6', 5)],
  'stack5': [('c1', 7), ('c8', 4), ('c4', 2)]},
 2: {'stack1': [('c13', 9), ('c12', 7), ('c6', 6), ('c5', 5)],
  'stack2': [('c4', 9)],
  'stack3': [('c2', 9), ('c3', 2)],
  'stack4': [('c11', 9), ('c9', 1)],
  'stack5': [('c1', 9), ('c10', 6), ('c8', 2), ('c7', 1)]},
 3: {'stack1': [('c7', 9), ('c9', 8), ('c6', 7), ('c3', 2)],
  'stack2': [('c2', 7), ('c11', 2)],
  'stack3': [('c1', 9), ('c5', 6), ('c12', 2)],
  'stack4': [('c4', 6), ('c10', 2)],
  'stack5': [('c8', 9)]},
 4: {'stack1': [('c7', 9), ('c9', 6), ('c4', 1)],
  'stack2': [('c6', 9)],
  'stack3': [('c2', 6), ('c12', 1)],
  'stack4': [('c3', 9), ('c5', 6), ('c11', 4), ('c10', 1)],
  'stack5': [('c8', 9), ('c1', 6)]},
 5: {'stack1': [('c11', 9), ('c13', 7), ('c9', 3)],
  'stack2': [('c1', 9), ('c2', 8), ('c10', 7)],
  'stack3': [('c4', 9), ('c14', 4), ('c6', 1)],
  'stack4': [('c8', 8)],
  'stack5': [('c7', 5), ('c12', 4), ('c5', 3), ('c3', 2)]},
 6: {'stack1': [('c2', 9), ('c7', 5), ('c12', 2), ('c3', 1)],
  'stack2': [('c6', 9), ('c11', 6), ('c1', 2)],
  'stack3': [('c9', 9), ('c5', 7), ('c4', 6), ('c13', 5)],
  'stack4': [('c8', 6)],
  'stack5': [('c10', 8)]},
 7: {'stack1': [('c8', 7), ('c9', 5), ('c5', 1)],
  'stack2': [('c6', 7)],
  'stack3': [('c4', 9), ('c10', 7), ('c13', 4), ('c1', 2)],
  'stack4': [('c11', 7), ('c2', 6), ('c3', 4)],
  'stack5': [('c7', 8), ('c12', 7)]},
 8: {'stack1': [('c11', 9), ('c10', 6), ('c5', 5), ('c8', 3)],
  'stack2': [('c1', 7), ('c9', 5), ('c7', 1)],
  'stack3': [('c3', 9), ('c6', 4), ('c4', 1)],
  'stack4': [('c13', 7)],
  'stack5': [('c12', 4), ('c2', 1)]},
 9: {'stack1': [('c9', 9), ('c1', 5), ('c4', 2)],
  'stack2': [('c10', 8), ('c6', 7)],
  'stack3': [('c2', 5)],
  'stack4': [('c5', 6), ('c7', 1)],
  'stack5': [('c3', 5), ('c8', 1)]},
 10: {'stack1': [('c9', 9), ('c14', 7), ('c6', 5)],
  'stack2': [('c2', 9), ('c3', 8), ('c12', 7)],
  'stack3': [('c8', 8), ('c7', 3), ('c5', 2)],
  'stack4': [('c1', 5)],
  'stack5': [('c13', 9), ('c10', 5), ('c11', 3), ('c4', 2)]},
 11: {'stack1': [('c2', 7), ('c12', 7), ('c14', 5), ('c11', 3)],
  'stack2': [('c1', 5), ('c4', 2), ('c7', 1)],
  'stack3': [('c6', 9), ('c8', 8)],
  'stack4': [('c3', 7), ('c10', 2)],
  'stack5': [('c5', 9), ('c9', 9), ('c13', 5)]},
 12: {'stack1': [('c5', 9), ('c6', 5)],
  'stack2': [('c7', 9)],
  'stack3': [('c9', 9), ('c10', 3), ('c4', 2)],
  'stack4': [('c1', 9), ('c2', 2)],
  'stack5': [('c3', 8), ('c8', 3)]},
 13: {'stack1': [('c10', 9), ('c12', 4), ('c1', 1)],
  'stack2': [('c4', 9)],
  'stack3': [('c9', 8), ('c13', 5), ('c14', 3)],
  'stack4': [('c5', 9), ('c6', 9), ('c11', 8), ('c8', 7)],
  'stack5': [('c2', 9), ('c7', 9), ('c3', 7)]},
 14: {'stack1': [('c1', 9), ('c10', 8), ('c9', 4)],
  'stack2': [('c7', 6), ('c2', 3)],
  'stack3': [('c4', 7), ('c6', 1)],
  'stack4': [('c12', 9), ('c8', 6), ('c11', 4), ('c3', 3)],
  'stack5': [('c5', 7)]},
 15: {'stack1': [('c14', 9), ('c13', 8), ('c11', 5)],
  'stack2': [('c9', 9), ('c6', 9), ('c12', 7), ('c3', 5)],
  'stack3': [('c2', 9), ('c4', 4), ('c1', 3)],
  'stack4': [('c8', 5), ('c7', 2), ('c10', 1)],
  'stack5': [('c5', 8)]},
 16: {'stack1': [('c3', 9), ('c8', 6), ('c9', 1)],
  'stack2': [('c4', 9), ('c11', 9), ('c10', 4), ('c6', 3)],
  'stack3': [('c1', 5), ('c14', 1)],
  'stack4': [('c5', 9), ('c13', 7), ('c12', 6)],
  'stack5': [('c2', 6), ('c7', 9)]},
 17: {'stack1': [('c6', 7), ('c10', 5)],
  'stack2': [('c4', 9), ('c7', 6)],
  'stack3': [('c9', 5), ('c11', 4), ('c5', 2)],
  'stack4': [('c1', 9), ('c3', 4), ('c12', 3), ('c8', 2)],
  'stack5': [('c2', 3)]},
 18: {'stack1': [('c8', 9), ('c9', 3)],
  'stack2': [('c3', 5), ('c2', 4), ('c6', 2)],
  'stack3': [('c7', 9)],
  'stack4': [('c4', 9), ('c5', 9)],
  'stack5': [('c1', 8), ('c10', 4), ('c11', 3)]},
 19: {'stack1': [('c6', 8)],
  'stack2': [('c5', 9), ('c7', 7), ('c4', 3)],
  'stack3': [('c9', 8)],
  'stack4': [('c1', 7), ('c2', 3), ('c3', 2)],
  'stack5': [('c8', 7), ('c10', 7)]},
 20: {'stack1': [('c10', 9)],
  'stack2': [('c1', 9), ('c4', 7), ('c11', 5)],
  'stack3': [('c7', 3), ('c9', 1)],
  'stack4': [('c2', 3)],
  'stack5': [('c3', 9), ('c5', 4), ('c6', 2), ('c8', 1)]}}


def place_containers(existing_bays, incoming_containers):
    # List to keep track of containers that couldn't be placed
    unplaced_containers = []

    # Iterate over each incoming container
    for container in incoming_containers:
        best_bay_id = None
        best_stack_name = None
        minimum_time_difference = float('inf')  # Initialize with infinity

        # Iterate over each bay and stack
        for bay_id, bay in existing_bays.items():
            for stack_name, stack in bay.items():
                # Check if stack is empty
                if not stack:
                    if minimum_time_difference > float('inf'):  # As it's an empty stack, we consider its time as infinity
                        best_bay_id = bay_id
                        best_stack_name = stack_name
                        minimum_time_difference = float('inf')
                else:
                    top_container = stack[-1]  # Top container of the current stack
                    current_time_difference = container[1] - top_container[1]

                    # Ensure that the incoming container has a later time than the top container
                    # and update the best bay and stack if needed
                    if current_time_difference > 0 and current_time_difference < minimum_time_difference:
                        best_bay_id = bay_id
                        best_stack_name = stack_name
                        minimum_time_difference = current_time_difference

        # If we found a suitable bay and stack, place the container
        if best_bay_id is not None and best_stack_name is not None:
            existing_bays[best_bay_id][best_stack_name].append(container)
        else:
            # If the container couldn't be placed, add it to the unplaced_containers list
            unplaced_containers.append(container)

    # Return the updated bays and the list of containers that couldn't be placed
    return existing_bays, unplaced_containers




def is_full(stack, H=4):
    # function to check if the stack is full
    return len(stack) >= H  # by default, a stack can hold 4 containers

def distribute_containers(existing_bays_keys, bays_dict, incoming_containers, max_tiers=4):
    """
    Distribute the incoming containers among the existing bays.
    """
    # Create a copy of the existing bays to avoid modifying the original dictionary
    updated_bays = copy.deepcopy(bays_dict)

    # Place containers and track where they are placed
    placed_containers_info = {}

    for container in incoming_containers:
        bay_num, stack_name, tier = place_container(container, updated_bays, max_tiers)
        if bay_num is not None:
            placed_containers_info[container[0]] = {'Bay': bay_num, 'Stack': stack_name, 'Tier': tier}

    # For easy identification, convert the updated bays dictionary into a list of dictionaries
    updated_bays_list = []
    for bay_key in existing_bays_keys:
        updated_bays_list.append({bay_key: updated_bays[bay_key]})

    return updated_bays_list, placed_containers_info

def place_container(container, bays, max_tiers):
    """
    Try to place the container in the bays and return the placement position.
    """
    container_id, time_window = container

    # Iterate through each bay, stack, and tier to find a spot for the container
    for bay_num in bays.keys():
        bay = bays[bay_num]
        for stack_name, stack in bay.items():
            # If the stack is not full and the top container has a greater time window, place the new container on top
            if len(stack) < max_tiers:
                # Check time window constraint
                if not stack or stack[-1][1] >= time_window:
                    stack.append(container)
                    return bay_num, stack_name, len(stack)  # Return the placement position
    return None, None, None



incoming_containers=[('c101', 8), ('c102', 4), ('c103', 3), ('c104', 1), ('c105', 9), ('c106', 4), ('c107', 2), ('c108', 1)]

incoming_containers_list = sorted(incoming_containers, key=lambda x: x[1], reverse=True)


crane_position=10
all_bays = list(existing_bays.keys())
sorted_bays = sorted(all_bays, key=lambda x: abs(crane_position - x))
sorted_bays_dict = OrderedDict((key, existing_bays[key]) for key in sorted_bays)

optimized_bays, container_positions = distribute_containers(sorted_bays, sorted_bays_dict, incoming_containers_list)
print(optimized_bays)
print(container_positions)


import matplotlib.pyplot as plt

def convert_to_single_dict(bays_list):
    single_dict = {}
    for bay_dict in bays_list:
        bay_num, bay = list(bay_dict.items())[0]
        single_dict[bay_num] = bay
    return single_dict

optimized_bays_dict = convert_to_single_dict(optimized_bays)


def plot_bays(bays, incoming_ids, max_stacks=5, max_tiers=4, pdf_filename='bays_plots.pdf'):
    # Determine the total number of unique time windows
    unique_times = set()
    for bay in bays.values():
        for stack in bay.values():
            for container in stack:
                unique_times.add(container[1])
    num_unique_times = len(unique_times)

    # Generate a color for each unique time window
    colors = cm.rainbow(np.linspace(0, 1, num_unique_times))

    with PdfPages(pdf_filename) as pdf:
        for bay_num, bay in sorted(bays.items(), key=lambda x: int(x[0])):

            fig, ax = plt.subplots()

            # Ensure that all stacks are displayed
            for i in range(max_stacks):
                stack_name = f'stack{i+1}'
                if stack_name not in bay:
                    bay[stack_name] = []  # initialize an empty list for the stack

            for i, (stack_name, stack) in enumerate(sorted(bay.items())):
                bottom = 0
                for j, (container_id, container_time) in enumerate(stack):
                    color_index = list(unique_times).index(container_time)
                    
                    if container_id in incoming_ids:
                        hatch_pattern = '/'
                    else:
                        hatch_pattern = ''

                    ax.bar(i, 1, bottom=bottom, color=colors[color_index], edgecolor='black', hatch=hatch_pattern, width=1)

                    ax.text(i, bottom + 0.5, f"{container_id} ({container_time})", color='black', ha='center', va='center')
                    bottom += 1

            ax.set_xticks(np.arange(max_stacks))
            ax.set_xticklabels([f'stack{i+1}' for i in range(max_stacks)])
            ax.set_yticks(np.arange(max_tiers) + 0.5)
            ax.set_yticklabels([f'Tier {i+1}' for i in range(max_tiers)])

            plt.tick_params(
                axis='x',
                which='both',
                bottom=False,
                top=False,
                labelbottom=True)

            ax.set_xlim(left=-0.5, right=max_stacks-0.5)
            ax.set_ylim(top=max_tiers)
            plt.title(f'Container Location in Bay {bay_num}')

            pdf.savefig(fig)
            plt.close()




incoming_ids = {container[0] for container in incoming_containers_list}
plot_bays(optimized_bays_dict, incoming_ids=incoming_ids)


